#include "Box.h"
#include "NanoTools.h"
#include "SofiaProcessRunner.h"

#include "SofiaNanoPipeline.h"
#include "include/SofiaNanoPipeline_internal.h"

auto b3d::tools::sofia_nano_pipeline::runSearchAndCreateNvdbSync(sofia::SofiaProcessRunner& processRunner,
															   SofiaNanoPipelineInitialParams pipelineParams)
	-> PipelineResult
{
	PipelineResult result;
	// All paths in sofiaParams should be absolute!
	pipelineParams.sofiaParams.setOrReplace("output.writeMask", "true");

	result.sofiaResult = processRunner.runSofiaSync(pipelineParams.sofiaParams);
	if (!result.sofiaResult.wasSuccess())
	{
		result.message = "SoFiA failed.";
		return result;
	}

	const auto paramsOutputPathStr = pipelineParams.sofiaParams.getStringValue("output.directory").value_or("");
	const auto outputDirectoryPath = paramsOutputPathStr.empty() ? pipelineParams.fitsInputFilePath.parent_path() : std::filesystem::path{ paramsOutputPathStr };
	const auto outputFilesNamePrefix = pipelineParams.sofiaParams.getStringValue("output.filename").value_or("");

	// Get Path to mask file. The mask cube will have the suffix _mask.fits
	const auto maskFilePath = outputDirectoryPath / (outputFilesNamePrefix + "_mask.fits");

	if (!std::filesystem::exists(maskFilePath))
	{
		result.message = "Mask file generated by SoFiA not found.";
		return result;
	}

	// Generate nvdb file with
	// - Fits file
	// - mask file
	// - path to nvdb output file
	result.nanoResult = b3d::tools::nano::convertFitsWithMaskToNano(
		pipelineParams.fitsInputFilePath, maskFilePath,pipelineParams.outputNvdbFilePath);

	if (!result.nanoResult.wasSuccess())
	{
		result.message = "Failed to create NVDB.";
		return result;
	}

	result.finished = true;
	result.message = "Success";
	result.returnCode = 0;

	return result;
}

auto b3d::tools::sofia_nano_pipeline::runSearchAndUpdateNvdbSync(sofia::SofiaProcessRunner& processRunner,
															   SofiaNanoPipelineUpdateParams pipelineParams)
	-> PipelineResult
{
	PipelineResult result;

	// All paths in sofiaParams should be absolute!
	// sofiaParams.setOrReplace("output.writeMask", "true");

	// Produces _mask-raw.fits. 
	pipelineParams.sofiaParams.setOrReplace("output.writeRawMask", "true");

	// TODO: This skips Reliability filter.
	// Disables Linker and all following steps.
	pipelineParams.sofiaParams.setOrReplace("linker.enable", "false");

	result.sofiaResult = processRunner.runSofiaSync(pipelineParams.sofiaParams, pipelineParams.sofiaWorkingDirectoy);
	if (result.sofiaResult.returnCode != 8)
	{
		result.message = "SoFiA failed.";
		return result;
	}
	const auto paramsOutputPathStr = pipelineParams.sofiaParams.getStringValue("output.directory").value_or("");

	const auto outputDirectoryPath = paramsOutputPathStr.empty() ? pipelineParams.fitsInputFilePath.parent_path() :
																   std::filesystem::path{ paramsOutputPathStr };

	const auto outputFilesNamePrefix = pipelineParams.sofiaParams.getStringValue("output.filename").value_or("");

	// Get Path to mask file. The mask cube will have the suffix _mask-raw.fits
	const auto maskFilePath = outputDirectoryPath / (outputFilesNamePrefix + "_mask-raw.fits");

	result.sofiaResult.resultFile = maskFilePath.generic_string();

	if (!std::filesystem::exists(maskFilePath))
	{
		result.message = "Mask file generated by SoFiA not found.";
		return result;
	}

	// Calculate Offset of Subregion
	// xmin, xmax, ymin, ymax, zmin, zmax
	auto regionString = pipelineParams.sofiaParams.getStringValue("input.region").value();
	
	std::array<int, 6> subRegionValues;
	// Extract subregion values from string
	{
		std::stringstream ss(regionString);
		std::string item;
		auto arrayPos = 0;
		while (std::getline(ss, item, ','))
		{
			subRegionValues[arrayPos] = std::stoi(item);
			arrayPos++;
		}
	}
	const auto subregion = b3d::common::Box3I{ { subRegionValues[0], subRegionValues[2], subRegionValues[4] },
								  { subRegionValues[1], subRegionValues[3], subRegionValues[5] } };

	// Run nvdb
	result.nanoResult = b3d::tools::nano::createNanoVdbWithExistingAndSubregion(
		pipelineParams.inputNvdbFilePath, pipelineParams.fitsInputFilePath, pipelineParams.maskInputFilePath,
		maskFilePath, subregion.lower, pipelineParams.outputNvdbFilePath);

	if (!result.nanoResult.wasSuccess())
	{
		result.message = "Failed to create NVDB.";
		return result;
	}

	result.finished = true;
	result.message = "Success";
	result.returnCode = 0;

	return result;
}
